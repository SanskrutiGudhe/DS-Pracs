#include <iostream> 
using namespace std; 
 
#define MAX_PAGES 6 
 
int webGraph[MAX_PAGES][MAX_PAGES]; 
bool visited[MAX_PAGES]; 
 
int queue_arr[MAX_PAGES]; 
int queue_front = 0; 
int queue_rear = 0; 
int queue_count = 0; 
 
bool queue_isEmpty() { 
    return queue_count == 0; 
} 
 
bool queue_isFull() { 
    return queue_count == MAX_PAGES; 
} 
 
void queue_enqueue(int page) { 
    if (!queue_isFull()) { 
        queue_arr[queue_rear] = page; 
        queue_rear = (queue_rear + 1) % MAX_PAGES; 
        queue_count++; 
    } 
} 
 
int queue_dequeue() { 
    if (!queue_isEmpty()) { 
        int page = queue_arr[queue_front]; 
        queue_front = (queue_front + 1) % MAX_PAGES; 
        queue_count--; 
        return page; 
    } 
    return -1; 
} 
 
void initializeGraph() { 
    for (int i = 0; i < MAX_PAGES; ++i) { 
        visited[i] = false; 
        for (int j = 0; j < MAX_PAGES; ++j) { 
            webGraph[i][j] = 0; 
        } 
    } 
} 
 
void addLink(int fromPage, int toPage) { 
    webGraph[fromPage][toPage] = 1; 
} 
 
void bfs_crawl(int startPage) { 
    visited[startPage] = true; 
    queue_enqueue(startPage); 
 
    cout << "BFS Crawl Order:" << endl; 
 
    while (!queue_isEmpty()) { 
        int currentPage = queue_dequeue(); 
         
        cout << "Indexing page: " << currentPage << endl; 
 
        for (int neighbor = 0; neighbor < MAX_PAGES; ++neighbor) { 
             
            if (webGraph[currentPage][neighbor] == 1 && !visited[neighbor]) { 
                 
                visited[neighbor] = true; 
                 
                queue_enqueue(neighbor); 
            } 
        } 
    } 
} 
 
int main() { 
    initializeGraph(); 
 
    addLink(0, 1); 
    addLink(0, 2); 
     
    addLink(1, 3); 
    addLink(1, 4); 
     
    addLink(2, 5); 
     
    addLink(4, 0); 
 
    bfs_crawl(0); 
 
    return 0; 
}
